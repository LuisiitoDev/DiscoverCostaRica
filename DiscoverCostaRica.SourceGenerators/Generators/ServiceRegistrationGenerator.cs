using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DiscoverCostaRica.SourceGenerators.Generators;

[Generator(LanguageNames.CSharp)]
public class ServiceRegistrationGenerator : IIncrementalGenerator
{
    private const string TransientServiceAttributeName = "TransientServiceAttribute";
    private const string ScopedServiceAttributeName = "ScopedServiceAttribute";
    private const string SingletonServiceAttributeName = "SingletonServiceAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax cls && cls.AttributeLists.Count > 0,
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, (spc, source) =>
        {
            var (compilation, classes) = source;
            var registrations = new List<string>();

            foreach (var classInfo in classes)
            {
                if (classInfo is null) continue;

                var (classSymbol, attributeName) = classInfo.Value;

                var interfaceType = classSymbol.Interfaces.FirstOrDefault()?.ToDisplayString();
                var implementationType = classSymbol.ToDisplayString();

                var registration = attributeName switch
                {
                    TransientServiceAttributeName =>
                        interfaceType != null
                            ? $"services.AddTransient<{interfaceType}, {implementationType}>();"
                            : $"services.AddTransient<{implementationType}>();",
                    ScopedServiceAttributeName =>
                        interfaceType != null
                            ? $"services.AddScoped<{interfaceType}, {implementationType}>();"
                            : $"services.AddScoped<{implementationType}>();",
                    SingletonServiceAttributeName =>
                        interfaceType != null
                            ? $"services.AddSingleton<{interfaceType}, {implementationType}>();"
                            : $"services.AddSingleton<{implementationType}>();",
                    _ => null
                };

                if (registration != null)
                {
                    registrations.Add(registration);
                }
            }

            if (registrations.Count > 0)
            {
                var assemblyName = compilation.AssemblyName ?? "Unknown";
                var sanitizedName = SanitizeAssemblyName(assemblyName);
                var sourceText = GenerateExtensionClass(registrations, sanitizedName);
                spc.AddSource($"ServiceRegistrationExtensions.{sanitizedName}.g.cs", SourceText.From(sourceText, Encoding.UTF8));
            }
        });
    }

    private static string SanitizeAssemblyName(string assemblyName)
    {
        return assemblyName.Replace(".", "_").Replace("-", "_");
    }

    private static (INamedTypeSymbol ClassSymbol, string AttributeName)? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        if (semanticModel.GetDeclaredSymbol(classDeclaration) is not INamedTypeSymbol classSymbol)
            return null;

        foreach (var attribute in classSymbol.GetAttributes())
        {
            var attributeName = attribute.AttributeClass?.Name;

            if (attributeName == TransientServiceAttributeName ||
                attributeName == ScopedServiceAttributeName ||
                attributeName == SingletonServiceAttributeName)
            {
                return (classSymbol, attributeName);
            }
        }

        return null;
    }

    private static string GenerateExtensionClass(List<string> registrations, string assemblyName)
    {
        return $@"// <auto-generated/>
            using Microsoft.Extensions.DependencyInjection;

            namespace DiscoverCostaRica.Generated
            {{
                public static class ServiceRegistrationExtensions_{assemblyName}
                {{
                    public static IServiceCollection AddGeneratedServices_{assemblyName}(this IServiceCollection services)
                    {{
                        {string.Join("\n            ", registrations)}
                        return services;
                    }}
                }}
            }}
            ";
    }
}
